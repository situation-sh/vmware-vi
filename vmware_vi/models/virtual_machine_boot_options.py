# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.virtual_machine_boot_options_bootable_device import VirtualMachineBootOptionsBootableDevice
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class VirtualMachineBootOptions(DataObject):
    """
    The *VirtualMachineBootOptions* data object defines the boot-time behavior of a virtual machine.  You can use the delay options to specify a time interval during which you can enter the virtual machine BIOS setup. These options provide a solution for the situation that occurs when the console attaches to the virtual machine after the boot sequence has passed the BIOS setup entry point.  ***Since:*** VI API 2.5 
    """ # noqa: E501
    boot_delay: Optional[StrictInt] = Field(default=None, description="Delay in milliseconds before starting the boot sequence.  The boot delay specifies a time interval between virtual machine power on or restart and the beginning of the boot sequence.  ***Since:*** VI API 2.5 ", alias="bootDelay")
    enter_bios_setup: Optional[StrictBool] = Field(default=None, description="If set to <code>true</code>, the virtual machine automatically enters BIOS setup the next time it boots.  The virtual machine resets this flag to <code>false</code> so that subsequent boots proceed normally.  ***Since:*** VI API 2.5 ", alias="enterBIOSSetup")
    efi_secure_boot_enabled: Optional[StrictBool] = Field(default=None, description="If set to <code>true</code>, the virtual machine's firmware will perform signature checks of any EFI images loaded during startup, and will refuse to start any images which do not pass those signature checks.  When creating a new VM: \\- If vim.vm.FlagInfo.vbsEnabled is set to <code>true</code>, and this flag is set to <code>false</code> error is returned. \\- If this flag is unset and vim.vm.FlagInfo.vbsEnabled is set to <code>true</code>, the value of this flag is set to <code>true</code>.  ***Since:*** vSphere API 6.5 ", alias="efiSecureBootEnabled")
    boot_retry_enabled: Optional[StrictBool] = Field(default=None, description="If set to <code>true</code>, a virtual machine that fails to boot will try again after the *VirtualMachineBootOptions.bootRetryDelay* time period has expired.  When <code>false</code>, the virtual machine waits indefinitely for you to initiate boot retry.  ***Since:*** vSphere API 4.1 ", alias="bootRetryEnabled")
    boot_retry_delay: Optional[StrictInt] = Field(default=None, description="Delay in milliseconds before a boot retry.  The boot retry delay specifies a time interval between virtual machine boot failure and the subsequent attempt to boot again. The virtual machine uses this value only if *VirtualMachineBootOptions.bootRetryEnabled* is true.  ***Since:*** vSphere API 4.1 ", alias="bootRetryDelay")
    boot_order: Optional[List[VirtualMachineBootOptionsBootableDevice]] = Field(default=None, description="Boot order.  Listed devices are used for booting. After list is exhausted, default BIOS boot device algorithm is used for booting. Note that order of the entries in the list is important: device listed first is used for boot first, if that one fails second entry is used, and so on. Platform may have some internal limit on the number of devices it supports. If bootable device is not reached before platform's limit is hit, boot will fail. At least single entry is supported by all products supporting boot order settings.  ***Since:*** vSphere API 5.0 ", alias="bootOrder")
    network_boot_protocol: Optional[StrictStr] = Field(default=None, description="Protocol to attempt during PXE network boot or NetBoot.  See also *VirtualMachineBootOptionsNetworkBootProtocolType_enum*.  ***Since:*** vSphere API 6.0 ", alias="networkBootProtocol")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of VirtualMachineBootOptions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of VirtualMachineBootOptions from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


