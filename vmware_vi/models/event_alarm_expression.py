# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictStr
from pydantic import Field
from vmware_vi.models.alarm_expression import AlarmExpression
from vmware_vi.models.event_alarm_expression_comparison import EventAlarmExpressionComparison
from vmware_vi.models.managed_entity_status_enum import ManagedEntityStatusEnum
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EventAlarmExpression(AlarmExpression):
    """
    An alarm expression that uses the event stream to trigger the alarm.  This alarm is triggered when an event matching this expression gets logged.  ***Since:*** VI API 2.5 
    """ # noqa: E501
    comparisons: Optional[List[EventAlarmExpressionComparison]] = Field(default=None, description="The attributes/values to compare.  ***Since:*** vSphere API 4.0 ")
    event_type: StrictStr = Field(description="Deprecated use <code>eventTypeId</code> instead.  The type of the event to trigger the alarm on.  ***Since:*** VI API 2.5 ", alias="eventType")
    event_type_id: Optional[StrictStr] = Field(default=None, description="The eventTypeId of the event to match.  The semantics of how eventTypeId matching is done is as follows: - If the event being matched is of type *EventEx*   or *ExtendedEvent*, then we match this value   against the <code>eventTypeId</code> (for <code>EventEx</code>) or   <code>eventId</code> (for <code>ExtendedEvent</code>) member of the Event. - Otherwise, we match it against the type of the Event itself.    Either <code>eventType</code> or <code>eventTypeId</code> _must_ be set.  ***Since:*** VI API 2.5 ", alias="eventTypeId")
    object_type: Optional[StrictStr] = Field(default=None, description="Name of the type of managed object on which the event is logged.  An event alarm defined on a *ManagedEntity* is propagated to child entities in the VirtualCenter inventory depending on the value of this attribute. If objectType is any of the following, the alarm is propagated down to all children of that type: - A datacenter: *Datacenter*. - A cluster of host systems: *ClusterComputeResource*. - A single host system: *HostSystem*. - A resource pool representing a set of physical resources on a single host:   *ResourcePool*. - A virtual machine: *VirtualMachine*. - A datastore: *Datastore*. - A network: *Network*. - A distributed virtual switch: *DistributedVirtualSwitch*.    If objectType is unspecified or not contained in the above list, the event alarm is not propagated down to child entities in the VirtualCenter inventory.  It is possible to specify an event alarm containing two (or more) different EventAlarmExpression's which contain different objectTypes. In such a case, the event is propagated to all child entities with specified type(s).  ***Since:*** vSphere API 4.0 ", alias="objectType")
    status: Optional[ManagedEntityStatusEnum] = None
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EventAlarmExpression from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EventAlarmExpression from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


