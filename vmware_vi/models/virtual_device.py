# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import StrictInt
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.description import Description
from vmware_vi.models.virtual_device_backing_info import VirtualDeviceBackingInfo
from vmware_vi.models.virtual_device_bus_slot_info import VirtualDeviceBusSlotInfo
from vmware_vi.models.virtual_device_connect_info import VirtualDeviceConnectInfo
from vmware_vi.models.virtual_device_device_group_info import VirtualDeviceDeviceGroupInfo
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class VirtualDevice(DataObject):
    """
    VirtualDevice is the base data object type for devices in a virtual machine.  This type contains enough information about a virtual device to allow clients to display devices they do not recognize. For example, a client with an older version than the server to which it connects may see a device without knowing what it is. 
    """ # noqa: E501
    key: StrictInt = Field(description="A unique key that distinguishes this device from other devices in the same virtual machine.  Keys are immutable but may be recycled; that is, a key does not change as long as the device is associated with a particular virtual machine. However, once a device is removed, its key may be used when another device is added.  This property is not read-only, but the client cannot control its value. Persistent device keys are always assigned and managed by the server, which guarantees that all devices will have non-negative key values.  When adding new devices, it may be necessary for a client to assign keys temporarily in order to associate controllers with devices in configuring a virtual machine. However, the server does not allow a client to reassign a device key, and the server may assign a different value from the one passed during configuration. Clients should ensure that existing device keys are not reused as temporary key values for the new device to be added (for example, by using unique negative integers as temporary keys).  When editing or deleting a device, clients must use the server-provided key to refer to an existing device. ")
    device_info: Optional[Description] = Field(default=None, alias="deviceInfo")
    backing: Optional[VirtualDeviceBackingInfo] = None
    connectable: Optional[VirtualDeviceConnectInfo] = None
    slot_info: Optional[VirtualDeviceBusSlotInfo] = Field(default=None, alias="slotInfo")
    controller_key: Optional[StrictInt] = Field(default=None, description="Object key for the controller object for this device.  This property contains the key property value of the controller device object. ", alias="controllerKey")
    unit_number: Optional[StrictInt] = Field(default=None, description="The unit number of this device on its controller.  This property is null if the controller property is null (for example, when the device is not attached to a specific controller object).  Normally, two devices on the same controller may not be assigned the same unit number. If multiple devices could exist on a controller, then unit number has to be specified to configure respective devices. ", alias="unitNumber")
    numa_node: Optional[StrictInt] = Field(default=None, description="The virtual NUMA node.  A negative number means there is no affinity for the device. A positive number is a vNUMA node. An unset value of numaNode is status-quo during Reconfigure time. If numaNode is unset during ConfigInfo, then it means there is no affinity for the device. ", alias="numaNode")
    device_group_info: Optional[VirtualDeviceDeviceGroupInfo] = Field(default=None, alias="deviceGroupInfo")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[List[str]] = '_typeName'

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[Dict[str, str]] = {
        'ArrayOfAnyURI': 'ArrayOfURI','ArrayOfBase64Binary': 'ArrayOfBinary','ArrayOfPropertyPath': 'ArrayOfPropPath','MethodName': 'PrimitiveMethodName','PropertyPath': 'PrimitivePropPath','TypeName': 'PrimitiveTypeName','anyURI': 'PrimitiveURI','base64Binary': 'PrimitiveBinary','boolean': 'PrimitiveBoolean','byte': 'PrimitiveByte','dateTime': 'PrimitiveDateTime','double': 'PrimitiveDouble','float': 'PrimitiveFloat','int': 'PrimitiveInt','long': 'PrimitiveLong','short': 'PrimitiveShort','string': 'PrimitiveString','ParaVirtualSCSIController': 'ParaVirtualSCSIController','VirtualAHCIController': 'VirtualAHCIController','VirtualBusLogicController': 'VirtualBusLogicController','VirtualCdrom': 'VirtualCdrom','VirtualController': 'VirtualController','VirtualDisk': 'VirtualDisk','VirtualE1000': 'VirtualE1000','VirtualE1000e': 'VirtualE1000e','VirtualEnsoniq1371': 'VirtualEnsoniq1371','VirtualEthernetCard': 'VirtualEthernetCard','VirtualFloppy': 'VirtualFloppy','VirtualHdAudioCard': 'VirtualHdAudioCard','VirtualIDEController': 'VirtualIDEController','VirtualKeyboard': 'VirtualKeyboard','VirtualLsiLogicController': 'VirtualLsiLogicController','VirtualLsiLogicSASController': 'VirtualLsiLogicSASController','VirtualMachineVMCIDevice': 'VirtualMachineVMCIDevice','VirtualMachineVMIROM': 'VirtualMachineVMIROM','VirtualMachineVideoCard': 'VirtualMachineVideoCard','VirtualNVDIMM': 'VirtualNVDIMM','VirtualNVDIMMController': 'VirtualNVDIMMController','VirtualNVMEController': 'VirtualNVMEController','VirtualPCIController': 'VirtualPCIController','VirtualPCIPassthrough': 'VirtualPCIPassthrough','VirtualPCNet32': 'VirtualPCNet32','VirtualPS2Controller': 'VirtualPS2Controller','VirtualParallelPort': 'VirtualParallelPort','VirtualPointingDevice': 'VirtualPointingDevice','VirtualPrecisionClock': 'VirtualPrecisionClock','VirtualSATAController': 'VirtualSATAController','VirtualSCSIController': 'VirtualSCSIController','VirtualSCSIPassthrough': 'VirtualSCSIPassthrough','VirtualSIOController': 'VirtualSIOController','VirtualSerialPort': 'VirtualSerialPort','VirtualSoundBlaster16': 'VirtualSoundBlaster16','VirtualSoundCard': 'VirtualSoundCard','VirtualSriovEthernetCard': 'VirtualSriovEthernetCard','VirtualTPM': 'VirtualTPM','VirtualUSB': 'VirtualUSB','VirtualUSBController': 'VirtualUSBController','VirtualUSBXHCIController': 'VirtualUSBXHCIController','VirtualVmxnet': 'VirtualVmxnet','VirtualVmxnet2': 'VirtualVmxnet2','VirtualVmxnet3': 'VirtualVmxnet3','VirtualVmxnet3Vrdma': 'VirtualVmxnet3Vrdma','VirtualWDT': 'VirtualWDT'
    }

    @classmethod
    def get_discriminator_value(cls, obj: Dict) -> str:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Union[Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self]:
        """Create an instance of VirtualDevice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Union[Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self, Self]:
        """Create an instance of VirtualDevice from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type:
            klass = globals()[object_type]
            return klass.from_dict(obj)
        else:
            raise ValueError("VirtualDevice failed to lookup discriminator value from " +
                             json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                             ", mapping: " + json.dumps(cls.__discriminator_value_class_map))

from vmware_vi.models.array_of_binary import ArrayOfBinary
from vmware_vi.models.array_of_prop_path import ArrayOfPropPath
from vmware_vi.models.array_of_uri import ArrayOfURI
from vmware_vi.models.para_virtual_scsi_controller import ParaVirtualSCSIController
from vmware_vi.models.primitive_binary import PrimitiveBinary
from vmware_vi.models.primitive_boolean import PrimitiveBoolean
from vmware_vi.models.primitive_byte import PrimitiveByte
from vmware_vi.models.primitive_date_time import PrimitiveDateTime
from vmware_vi.models.primitive_double import PrimitiveDouble
from vmware_vi.models.primitive_float import PrimitiveFloat
from vmware_vi.models.primitive_int import PrimitiveInt
from vmware_vi.models.primitive_long import PrimitiveLong
from vmware_vi.models.primitive_method_name import PrimitiveMethodName
from vmware_vi.models.primitive_prop_path import PrimitivePropPath
from vmware_vi.models.primitive_short import PrimitiveShort
from vmware_vi.models.primitive_string import PrimitiveString
from vmware_vi.models.primitive_type_name import PrimitiveTypeName
from vmware_vi.models.primitive_uri import PrimitiveURI
from vmware_vi.models.virtual_ahci_controller import VirtualAHCIController
from vmware_vi.models.virtual_bus_logic_controller import VirtualBusLogicController
from vmware_vi.models.virtual_cdrom import VirtualCdrom
from vmware_vi.models.virtual_controller import VirtualController
from vmware_vi.models.virtual_disk import VirtualDisk
from vmware_vi.models.virtual_e1000 import VirtualE1000
from vmware_vi.models.virtual_e1000e import VirtualE1000e
from vmware_vi.models.virtual_ensoniq1371 import VirtualEnsoniq1371
from vmware_vi.models.virtual_ethernet_card import VirtualEthernetCard
from vmware_vi.models.virtual_floppy import VirtualFloppy
from vmware_vi.models.virtual_hd_audio_card import VirtualHdAudioCard
from vmware_vi.models.virtual_ide_controller import VirtualIDEController
from vmware_vi.models.virtual_keyboard import VirtualKeyboard
from vmware_vi.models.virtual_lsi_logic_controller import VirtualLsiLogicController
from vmware_vi.models.virtual_lsi_logic_sas_controller import VirtualLsiLogicSASController
from vmware_vi.models.virtual_machine_video_card import VirtualMachineVideoCard
from vmware_vi.models.virtual_machine_vmci_device import VirtualMachineVMCIDevice
from vmware_vi.models.virtual_machine_vmirom import VirtualMachineVMIROM
from vmware_vi.models.virtual_nvdimm import VirtualNVDIMM
from vmware_vi.models.virtual_nvdimm_controller import VirtualNVDIMMController
from vmware_vi.models.virtual_nvme_controller import VirtualNVMEController
from vmware_vi.models.virtual_parallel_port import VirtualParallelPort
from vmware_vi.models.virtual_pc_net32 import VirtualPCNet32
from vmware_vi.models.virtual_pci_controller import VirtualPCIController
from vmware_vi.models.virtual_pci_passthrough import VirtualPCIPassthrough
from vmware_vi.models.virtual_pointing_device import VirtualPointingDevice
from vmware_vi.models.virtual_precision_clock import VirtualPrecisionClock
from vmware_vi.models.virtual_ps2_controller import VirtualPS2Controller
from vmware_vi.models.virtual_sata_controller import VirtualSATAController
from vmware_vi.models.virtual_scsi_controller import VirtualSCSIController
from vmware_vi.models.virtual_scsi_passthrough import VirtualSCSIPassthrough
from vmware_vi.models.virtual_serial_port import VirtualSerialPort
from vmware_vi.models.virtual_sio_controller import VirtualSIOController
from vmware_vi.models.virtual_sound_blaster16 import VirtualSoundBlaster16
from vmware_vi.models.virtual_sound_card import VirtualSoundCard
from vmware_vi.models.virtual_sriov_ethernet_card import VirtualSriovEthernetCard
from vmware_vi.models.virtual_tpm import VirtualTPM
from vmware_vi.models.virtual_usb import VirtualUSB
from vmware_vi.models.virtual_usb_controller import VirtualUSBController
from vmware_vi.models.virtual_usbxhci_controller import VirtualUSBXHCIController
from vmware_vi.models.virtual_vmxnet import VirtualVmxnet
from vmware_vi.models.virtual_vmxnet2 import VirtualVmxnet2
from vmware_vi.models.virtual_vmxnet3 import VirtualVmxnet3
from vmware_vi.models.virtual_vmxnet3_vrdma import VirtualVmxnet3Vrdma
from vmware_vi.models.virtual_wdt import VirtualWDT
# TODO: Rewrite to not use raise_errors
VirtualDevice.model_rebuild(raise_errors=False)

