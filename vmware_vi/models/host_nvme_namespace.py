# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List
from pydantic import StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostNvmeNamespace(DataObject):
    """
    This data object represents an NVM Express Namespace.  In the NVME model, the underlying non-volatile storage medium is exposed via namespaces. For further information, see: - \"NVM Express over Fabrics 1.0\", Section 1.5.2,   \"NVM Subsystem\". - \"NVM Express 1.3\", section 6.1, \"Namespaces\".    ***Since:*** vSphere API 7.0 
    """ # noqa: E501
    key: StrictStr = Field(description="The linkable identifier.  This is a unique identifier of the NVME namespace within the host system.  ***Since:*** vSphere API 7.0 ")
    name: StrictStr = Field(description="The name of the namespace.  The name identifies the underlying storage exposed by the NvmeNamespace. In multipath scenarios, two namespaces can have the same name if they expose the same underlying storage through different NVME controllers.  ***Since:*** vSphere API 7.0 ")
    id: StrictInt = Field(description="The namespace ID is an identifier used by an NVME controller to provide access to a namespace.  The namespace ID is only unique among the namespaces attached to the same controller. For details, see: - \"NVM Express 1.3\", section 6.1, \"Namespaces\".    ***Since:*** vSphere API 7.0 ")
    block_size: StrictInt = Field(description="Block size of the namespace in bytes.  Namespaces are comprised of a number of logical blocks with a fixed size - the smallest units of data that may be read or written by the NVME controller.  ***Since:*** vSphere API 7.0 ", alias="blockSize")
    capacity_in_blocks: StrictInt = Field(description="The maximum number of logical blocks that may be allocated in the namespace at any point in time.  Corresponds to the NCAP field in the Identify Namespace data structure: - \"NVM Express 1.3\", Section 5.15, Figure 114,   \"Identify Namespace Data Structure\"    ***Since:*** vSphere API 7.0 ", alias="capacityInBlocks")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostNvmeNamespace from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostNvmeNamespace from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


