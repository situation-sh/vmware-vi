# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.cluster_das_admission_control_policy import ClusterDasAdmissionControlPolicy
from vmware_vi.models.cluster_das_vm_settings import ClusterDasVmSettings
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.managed_object_reference import ManagedObjectReference
from vmware_vi.models.option_value import OptionValue
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ClusterDasConfigInfo(DataObject):
    """
    The *ClusterDasConfigInfo* data object contains configuration data about the HA service on a cluster.  All fields are optional. If you set the <code>modify</code> parameter to <code>true</code> when you call *ComputeResource.ReconfigureComputeResource_Task*, an unset property has no effect on the existing property value in the cluster configuration on the Server. If you set the <code>modify</code> parameter to <code>false</code> when you reconfigure a cluster, the cluster configuration is reverted to the default values, then the new configuration values are applied. 
    """ # noqa: E501
    enabled: Optional[StrictBool] = Field(default=None, description="Flag to indicate whether or not vSphere HA feature is enabled. ")
    vm_monitoring: Optional[StrictStr] = Field(default=None, description="Level of HA Virtual Machine Health Monitoring Service.  You can monitor both guest and application heartbeats, guest heartbeats only, or you can disable the service. See *ClusterDasConfigInfoVmMonitoringState_enum*. The default value is *vmMonitoringDisabled*.  The Service level specified for the cluster determines the possible monitoring settings that you can use for individual virtual machines. See *ClusterVmToolsMonitoringSettings*.*ClusterVmToolsMonitoringSettings.vmMonitoring*.  ***Since:*** vSphere API 4.0 ", alias="vmMonitoring")
    host_monitoring: Optional[StrictStr] = Field(default=None, description="Determines whether HA restarts virtual machines after a host fails.  The default value is *ClusterDasConfigInfoServiceState_enum*.*enabled*. This property is meaningful only when *ClusterDasConfigInfo*.*ClusterDasConfigInfo.enabled* is <code>true</code>.  When <code>hostMonitoring</code> is *enabled*, HA restarts virtual machines after a host fails.  When <code>hostMonitoring</code> is *disabled*, HA does not restart virtual machines after a host fails. The status of Host Monitoring does not affect other services such as virtual machine Health Monitoring or Fault Tolerance. The rest of the cluster operations follow normal processing. No configuration information is lost and re-enabling the service is a quick operation.  ***Since:*** vSphere API 4.0 ", alias="hostMonitoring")
    vm_component_protecting: Optional[StrictStr] = Field(default=None, description="This property indicates if vSphere HA VM Component Protection service is enabled.  The default value is *disabled*.  When <code>vmComponentProtecting</code> is set to *disabled*, reaction to all types of VM component failures is disabled.  When <code>vmComponentProtecting</code> is set to *enabled*, VM Component Protection service will detect and react to component failures. The actual reaction is determined by *ClusterVmComponentProtectionSettings* which is referenced by both cluster level configuration (*ClusterDasConfigInfo.defaultVmSettings*) and per-VM override *ClusterConfigInfoEx.dasVmConfig*.  ***Since:*** vSphere API 6.0 ", alias="vmComponentProtecting")
    failover_level: Optional[StrictInt] = Field(default=None, description="Deprecated as of vSphere API 4.0, use *ClusterFailoverLevelAdmissionControlPolicy* to set *ClusterDasConfigInfo.admissionControlPolicy*.  Configured failover level.  This is the number of physical host failures that can be tolerated without impacting the ability to satisfy the minimums for all running virtual machines. Acceptable values range from one to four. ", alias="failoverLevel")
    admission_control_policy: Optional[ClusterDasAdmissionControlPolicy] = Field(default=None, alias="admissionControlPolicy")
    admission_control_enabled: Optional[StrictBool] = Field(default=None, description="Flag that determines whether strict admission control is enabled.  When you use admission control, the following operations are prevented, if doing so would violate the *ClusterDasConfigInfo.admissionControlPolicy*. - Powering on a virtual machine in the cluster. - Migrating a virtual machine into the cluster. - Increasing the CPU or memory reservation of powered-on   virtual machines in the cluster.    With admission control disabled, there is no assurance that all virtual machines in the HA cluster can be restarted after a host failure. VMware recommends that you do not disable admission control, but you might need to do so temporarily, for the following reasons: - If you need to violate the failover constraints when there   are not enough resources to support them (for example,   if you are placing hosts in standby mode to test them   for use with DPM). - If an automated process needs to take actions that might   temporarily violate the failover constraints (for example,   as part of an upgrade directed by VMware Update Manager). - If you need to perform testing or maintenance operations. ", alias="admissionControlEnabled")
    default_vm_settings: Optional[ClusterDasVmSettings] = Field(default=None, alias="defaultVmSettings")
    option: Optional[List[OptionValue]] = Field(default=None, description="Advanced settings. ")
    heartbeat_datastore: Optional[List[ManagedObjectReference]] = Field(default=None, description="The list of preferred datastores to use for storage heartbeating.  Each of the specified datastores should be active and mounted by more than one host. There is no limit on the number of specified datastores and no priority among them. The specified datastores will replace those previously specified and an empty list will delete all such earlier specified ones.  vCenter Server chooses the heartbeat datastores for a host from the set specified by *ClusterDasConfigInfo.hBDatastoreCandidatePolicy*. The choice is made based on datastore connectivity and storage array redundancy (in case of VMFS).  The final set of selected heartbeat datastores is reported via *ClusterDasAdvancedRuntimeInfo.heartbeatDatastoreInfo*.  ***Since:*** vSphere API 5.0  Refers instances of *Datastore*. ", alias="heartbeatDatastore")
    h_b_datastore_candidate_policy: Optional[StrictStr] = Field(default=None, description="The policy on what datastores will be used by vCenter Server to choose heartbeat datastores.  See *ClusterDasConfigInfoHBDatastoreCandidate_enum* for all options. The default value is *allFeasibleDsWithUserPreference*.  ***Since:*** vSphere API 5.0 ", alias="hBDatastoreCandidatePolicy")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ClusterDasConfigInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ClusterDasConfigInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


