# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictInt
from pydantic import Field
from vmware_vi.models.cluster_das_advanced_runtime_info import ClusterDasAdvancedRuntimeInfo
from vmware_vi.models.cluster_das_failover_level_advanced_runtime_info_host_slots import ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots
from vmware_vi.models.cluster_das_failover_level_advanced_runtime_info_slot_info import ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo
from vmware_vi.models.cluster_das_failover_level_advanced_runtime_info_vm_slots import ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ClusterDasFailoverLevelAdvancedRuntimeInfo(ClusterDasAdvancedRuntimeInfo):
    """
    Advanced runtime information related to the high availability service for a cluster that has been configured with a failover level admission control policy.  See *ClusterFailoverLevelAdmissionControlPolicy*.  ***Since:*** vSphere API 4.0 
    """ # noqa: E501
    slot_info: ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo = Field(alias="slotInfo")
    total_slots: StrictInt = Field(description="The total number of slots available in the cluster.  See also *ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo*.  ***Since:*** vSphere API 4.0 ", alias="totalSlots")
    used_slots: StrictInt = Field(description="The number of slots currently being used.  See also *ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo*.  ***Since:*** vSphere API 4.0 ", alias="usedSlots")
    unreserved_slots: StrictInt = Field(description="The number of slots that are not used by currently powered on virtual machines and not reserved to satisfy the configured failover level.  This number gives an indication of how many additional virtual machines can be powered on in this cluster without violating the failover level (assuming the new virtual machine's reservations are satisfied by the current slot size). This value is computed as follows (where m is the configured failover level): Remove the m largest hosts (ie. the ones with the most slots) from the list of \"good\" hosts (see *ClusterDasFailoverLevelAdvancedRuntimeInfo.totalGoodHosts*). Sum up the number of slots on the remaining hosts and deduct the number of currently used slots (see *ClusterDasFailoverLevelAdvancedRuntimeInfo.usedSlots*). If this number is negative, use zero instead.  See also *ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo*.  ***Since:*** vSphere API 4.0 ", alias="unreservedSlots")
    total_vms: StrictInt = Field(description="The total number of powered on vms in the cluster.  ***Since:*** vSphere API 4.0 ", alias="totalVms")
    total_hosts: StrictInt = Field(description="The total number of hosts in the cluster.  ***Since:*** vSphere API 4.0 ", alias="totalHosts")
    total_good_hosts: StrictInt = Field(description="The total number of connected hosts that are not in maintance mode and that do not have any DAS-related config issues on them.  ***Since:*** vSphere API 4.0 ", alias="totalGoodHosts")
    host_slots: Optional[List[ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots]] = Field(default=None, alias="hostSlots")
    vms_requiring_multiple_slots: Optional[List[ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots]] = Field(default=None, description="The list of virtual machines whose reservations and memory overhead are not satisfied by a single slot.  ***Since:*** vSphere API 5.1 ", alias="vmsRequiringMultipleSlots")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ClusterDasFailoverLevelAdvancedRuntimeInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ClusterDasFailoverLevelAdvancedRuntimeInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


