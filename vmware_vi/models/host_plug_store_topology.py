# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional

from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.host_plug_store_topology_adapter import HostPlugStoreTopologyAdapter
from vmware_vi.models.host_plug_store_topology_device import HostPlugStoreTopologyDevice
from vmware_vi.models.host_plug_store_topology_path import HostPlugStoreTopologyPath
from vmware_vi.models.host_plug_store_topology_plugin import HostPlugStoreTopologyPlugin
from vmware_vi.models.host_plug_store_topology_target import HostPlugStoreTopologyTarget
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostPlugStoreTopology(DataObject):
    """
    This data object represents the plug-store topology on a host system.  Through this data object, the storage structure of a system that utilizes the plug-store architecture can be presented.  The object entity-relationship diagram is modeled below:        ------------------------------------------------------------       |             0..N             0..N      0..N              |       |   Plugin ----->  Device  ------>  Path  <------  Adapter |       |                          <------   |    ------>          |       |                          0,1       |          1          |       |                                    |                     |       |                                    | 0,1                 |       |                                   \\|/                    |       |                                  Target                  |       ------------------------------------------------------------ Description and reasoning behind the relationships:  When a storage device driver is loaded, it claims a PCI device as a host bus adapter. This host bus adapter is represented as an Adapter. The PCI device identifier is a property on the HostBusAdapter in the Adapter.  Once the host bus adapter is on the system, the hardware bus is scanned. If a storage Device is found on the bus, the communication path to the Device from the the host bus adapter is represented by a Path. A Device may have more than one Path. How those Paths are composed to create a Device is determined by a storage Plugin.  When a storage Plugin is loaded, it claims a set of Paths. It groups these Paths into a set of Devices. Devices are hence associated with a set of Paths that might be used to provide a single logical device such as in the case of multipathing. Devices may be also composed of zero Paths meaning that they do not directly use a host bus adapter for communication with underlying storage.  The purpose of this data object is to represent the topology of storage as seen by the base plug-store system. There is some overlap with information in other objects such as ScsiTopology which is only applicable when a particular \"native multipathing\" plugin is used. This data object provides the complete inventory of Devices and Paths. Hence it provides a superset of Device mappings over data object such as ScsiTopology and Multipa  The use cases that this data object accommodates includes the following non-exhaustive list: - Enumerate paths on a host bus adapter. - Enumerate paths on a storage device. - Conveniently access the devices a host bus adapter is   associated with by traversing the path. - Determine which plugin a device belongs. - Determine which paths are claimed by a plugin by   accumulating the paths of all device of the plugin. - Determine which plugin a path belongs to by accessing its   device and finding that device in the Plugin list.    ***Since:*** vSphere API 4.0 
    """ # noqa: E501
    adapter: Optional[List[HostPlugStoreTopologyAdapter]] = Field(default=None, description="List of host bus adapters in the plug store inventory.  ***Since:*** vSphere API 4.0 ")
    path: Optional[List[HostPlugStoreTopologyPath]] = Field(default=None, description="List of paths in the plug store inventory.  ***Since:*** vSphere API 4.0 ")
    target: Optional[List[HostPlugStoreTopologyTarget]] = Field(default=None, description="Partial list of targets as seen by the host.  The list of targets may not be exhaustive on the host.  ***Since:*** vSphere API 4.0 ")
    device: Optional[List[HostPlugStoreTopologyDevice]] = Field(default=None, description="List of devices in the plug store inventory.  ***Since:*** vSphere API 4.0 ")
    plugin: Optional[List[HostPlugStoreTopologyPlugin]] = Field(default=None, description="List of plugins in the plug store inventory.  ***Since:*** vSphere API 4.0 ")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostPlugStoreTopology from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostPlugStoreTopology from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


