# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OvfFileItem(DataObject):
    """
    An FileItem represents a file that must be uploaded by the caller when the inventory objects has been created in VI.  These objects are created by *ResourcePool.importVApp*.  Files can either be new files, in which case the \"create\" flag will be true, or updates to existing files in VI. The latter is used to support the OVF parentRef mechanism for Disks.  ***Since:*** vSphere API 4.0 
    """ # noqa: E501
    device_id: StrictStr = Field(description="Uniquely identifies the device (disk, CD-ROM etc.) within the entity hierarchy.  When *ResourcePool.importVApp* is called to create the *VirtualMachine*s and *VirtualApp*s, it returns a map, device ID -&gt; URL, of where to upload the backing files.  ***Since:*** vSphere API 4.0 ", alias="deviceId")
    path: StrictStr = Field(description="The path of the item to upload, relative to the path of the OVF descriptor.  ***Since:*** vSphere API 4.0 ")
    compression_method: Optional[StrictStr] = Field(default=None, description="The compression method as specified by the OVF specification (for example \"gzip\" or \"bzip2\").  ***Since:*** vSphere API 4.0 ", alias="compressionMethod")
    chunk_size: Optional[StrictInt] = Field(default=None, description="The chunksize as specified by the OVF specification.  If this attribute is set, the \"path\" attribute is a prefix to each chunk of the complete file. For example, if chunksize is 2000000000 bytes, the actual files might be: myfile.000000000 (2000000000 bytes) myfile.000000001 (2000000000 bytes) myfile.000000002 (1500000000 bytes)  ***Since:*** vSphere API 4.0 ", alias="chunkSize")
    size: Optional[StrictInt] = Field(default=None, description="The complete size of the file, if it is specified in the OVF descriptor.  ***Since:*** vSphere API 4.0 ")
    cim_type: StrictInt = Field(description="The CIM type of the device for which this file provides backing.  For example, the value 17 means \"Disk drive\".  ***Since:*** vSphere API 4.0 ", alias="cimType")
    create: StrictBool = Field(description="True if the item is not expected to exist in the infrastructure and should therefore be created by the caller (for example using HTTP PUT).  ***Since:*** vSphere API 4.0 ")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OvfFileItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OvfFileItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


