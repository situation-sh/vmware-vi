# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.file_query import FileQuery
from vmware_vi.models.file_query_flags import FileQueryFlags
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostDatastoreBrowserSearchSpec(DataObject):
    """
    The data object type describes a search for files in one or more datastores.  The properties do not include the starting datastore path because that path is a separate parameter to the search method.  A SearchSpec contains the query parameters and some global search modifiers. 
    """ # noqa: E501
    query: Optional[List[FileQuery]] = Field(default=None, description="The set of file types to match, search criteria specific to the file type, and the amount of detail for a file.  These search parameters are specific to a file type, meaning that they can be specified only if the file type to which they are associated is in the set. A file type cannot appear more than once in the set.  If this query object is not present, then all files providing only file level details are matched. ")
    details: Optional[FileQueryFlags] = None
    search_case_insensitive: Optional[StrictBool] = Field(default=None, description="This flag indicates whether or not to search using a case insensitive match on type.  In general the algorithm used to match file types relies on file extensions. Although the specific file extensions used are encapsulated by this API, clients are still allowed to modify the filtering behavior.  By default, the DatastoreBrowser uses a platform-consistent algorithm to determine if a file is of a type. Specifically on Linux, where case is important, the search is case sensitive. On Windows, case is not important, so the search is case insensitive.  In an environment with heterogenous platforms, being platform-consistent may not be desirable. As a result, the default behavior can be overridden by setting this optional flag. ", alias="searchCaseInsensitive")
    match_pattern: Optional[List[StrictStr]] = Field(default=None, description="Specifies a list of file patterns that must match for a file to be returned.  This search property is a filter that applies globally so that only files matching the specified patterns are returned, regardless of the other search parameters. ", alias="matchPattern")
    sort_folders_first: Optional[StrictBool] = Field(default=None, description="By default, files are sorted in alphabetical order regardless of file type.  If this flag is set to \"true\", folders are placed at the start of the list of results in alphabetical order. The remaining files follow in alphabetical order. ", alias="sortFoldersFirst")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostDatastoreBrowserSearchSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostDatastoreBrowserSearchSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


