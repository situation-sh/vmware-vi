# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostNvmeDisconnectSpec(DataObject):
    """
    Specifies the parameters necessary to disconnect an NVME controller from a given NVME over Fabrics adapter.  ***Since:*** vSphere API 7.0 
    """ # noqa: E501
    hba_name: StrictStr = Field(description="The device name of the NVME over Fabrics host bus adapter.  ***Since:*** vSphere API 7.0 ", alias="hbaName")
    subnqn: Optional[StrictStr] = Field(default=None, description="NVME Qualified Name of the NVM subsystem to disconnect from.  If controllerNumber is not specified, the subsystem qualified name has to be specified and any controllers exposed by that subsystem will be disconnected from the specified adapter. This is particularly convenient for the dynamic controller model, where the mapping subsystemNQN &lt;-&gt; ctrlNumber is expected to be 1:1. If controllerNumber is also specified, this value is ignored.  ***Since:*** vSphere API 7.0 ")
    controller_number: Optional[StrictInt] = Field(default=None, description="Controller number of the controller to be disconnected.  If this value is set, the subsystemQualifiedName can be left unset and the controller whose controllerNumber field matches this value will be disconnected from the specified adapter. If this value is not set, subsystemQualifiedName must be set.  ***Since:*** vSphere API 7.0 ", alias="controllerNumber")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostNvmeDisconnectSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostNvmeDisconnectSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


