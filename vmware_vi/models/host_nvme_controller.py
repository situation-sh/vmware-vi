# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.host_host_bus_adapter import HostHostBusAdapter
from vmware_vi.models.host_nvme_namespace import HostNvmeNamespace
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostNvmeController(DataObject):
    """
    This data object represents an NVME controller.  Some terminology is borrowed from the NVM Express over Fabrics and the NVM Express 1.3 specifications, which are available at the following address: https://nvmexpress.org/resources/specifications/  ***Since:*** vSphere API 7.0 
    """ # noqa: E501
    key: StrictStr = Field(description="The linkable identifier.  ***Since:*** vSphere API 7.0 ")
    controller_number: StrictInt = Field(description="The controller number uniquely identifies the NVME Controller within its HostSystem.  This should not be confused with Controller ID (see \"NVM Express over Fabrics 1.0\", Section 4.2, \"Controller model\" for details), which only serves as an identifier within a particular NVME subsystem.  ***Since:*** vSphere API 7.0 ", alias="controllerNumber")
    subnqn: StrictStr = Field(description="The NVME subsystem qualified name.  Each NVME controller is associated with an NVME subsystem which can present a collection of controllers to the adapter. For more details, refer to: - \"NVM Express over Fabrics 1.0\", Section 1.5.2,   \"NVM Subsystem\".    ***Since:*** vSphere API 7.0 ")
    name: StrictStr = Field(description="Name of the controller.  Each controller has a name. For NVME over Fabrics controllers, it is generated when the controller is connected to an NVME over Fabrics adapter.  ***Since:*** vSphere API 7.0 ")
    associated_adapter: HostHostBusAdapter = Field(alias="associatedAdapter")
    transport_type: StrictStr = Field(description="The transport type supported by the controller.  The set of possible values is described in *HostNvmeTransportType_enum*. For details, see: - \"NVM Express over Fabrics 1.0\", Section 1.5.1,   \"Fabrics and Transports\".    ***Since:*** vSphere API 7.0 ", alias="transportType")
    fused_operation_supported: StrictBool = Field(description="Indicates whether fused operations are supported by the controller.  An NVME controller may support fused operations. This is required to support shared storage, otherwise data corruption may occur. For more details, see: - \"NVM Express 1.3\", Section 6.2, \"Fused Operations\".    ***Since:*** vSphere API 7.0 ", alias="fusedOperationSupported")
    number_of_queues: StrictInt = Field(description="The number of I/O queues allocated for the controller.  ***Since:*** vSphere API 7.0 ", alias="numberOfQueues")
    queue_size: StrictInt = Field(description="The size of each of the I/O queues.  This will not be greater than the Maximum Queue Entries Supported (mqes) value for the controller. For more information, see: - \"NVM Express 1.3\", section 3.1, \"Register definition\".    ***Since:*** vSphere API 7.0 ", alias="queueSize")
    attached_namespace: Optional[List[HostNvmeNamespace]] = Field(default=None, description="List of NVME namespaces attached to the controller.  Namespaces provide access to a non-volatile storage medium which is part of the NVM subsystem. For an overview, see: - \"NVM Express over Fabrics 1.0\", Section 1.5.2,   \"NVM Subsystem\". - \"NVM Express 1.3\", section 6.1, \"Namespaces\".    ***Since:*** vSphere API 7.0 ", alias="attachedNamespace")
    vendor_id: Optional[StrictStr] = Field(default=None, description="The vendor ID of the controller, if available.  ***Since:*** vSphere API 7.0 ", alias="vendorId")
    model: Optional[StrictStr] = Field(default=None, description="The model name of the controller, if available.  ***Since:*** vSphere API 7.0 ")
    serial_number: Optional[StrictStr] = Field(default=None, description="The serial number of the controller, if available.  ***Since:*** vSphere API 7.0 ", alias="serialNumber")
    firmware_version: Optional[StrictStr] = Field(default=None, description="The firmware version of the controller, if available.  ***Since:*** vSphere API 7.0 ", alias="firmwareVersion")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostNvmeController from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostNvmeController from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


