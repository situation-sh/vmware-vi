# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictStr
from pydantic import Field
from vmware_vi.models.cluster_rule_info import ClusterRuleInfo
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.managed_object_reference import ManagedObjectReference
from vmware_vi.models.virtual_machine_clone_spec import VirtualMachineCloneSpec
from vmware_vi.models.virtual_machine_config_spec import VirtualMachineConfigSpec
from vmware_vi.models.virtual_machine_move_priority_enum import VirtualMachineMovePriorityEnum
from vmware_vi.models.virtual_machine_relocate_spec import VirtualMachineRelocateSpec
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class PlacementSpec(DataObject):
    """
    PlacementSpec encapsulates all of the information passed to the *ClusterComputeResource.PlaceVm* method, which asks DRS for recommendations for target hosts and datastores for placing a virtual machine and its virtual disks in a cluster using unified VMotion.  ***Since:*** vSphere API 6.0 
    """ # noqa: E501
    priority: Optional[VirtualMachineMovePriorityEnum] = None
    vm: Optional[ManagedObjectReference] = None
    config_spec: Optional[VirtualMachineConfigSpec] = Field(default=None, alias="configSpec")
    relocate_spec: Optional[VirtualMachineRelocateSpec] = Field(default=None, alias="relocateSpec")
    hosts: Optional[List[ManagedObjectReference]] = Field(default=None, description="A list of compatible hosts for the virtual machine.  This list is ignored if relocateSpec.host is set. For both intra-vCenter and cross-vCenter migrations, this list is required if relocateSpec.host is unset. If neither relocateSpec.host nor a list of compatible hosts are specified, all hosts in the cluster will be considered, in which case, the selected hosts in the PlacementResult are not guaranteed to be compatible with the incoming virtual machine.  ***Since:*** vSphere API 6.0  Refers instances of *HostSystem*. ")
    datastores: Optional[List[ManagedObjectReference]] = Field(default=None, description="A list of compatible datastores for the virtual machine.  This list is ignored if relocateSpec.datastore is set. For both intra-vCenter and cross-vCenter migrations, this list is required if relocateSpec.datastore is unset. If neither relocateSpec.datastore nor a list of compatible datastores are specified, all datastores connected to hosts in the cluster will be considered, in which case, the selected datastores in the PlacementResult are not guaranteed to be compatible with the incoming virtual machine.  ***Since:*** vSphere API 6.0  Refers instances of *Datastore*. ")
    storage_pods: Optional[List[ManagedObjectReference]] = Field(default=None, description="A list of compatible datastore clusters for the virtual machine.  This list is ignored if relocateSpec.datastore is set. For both intra-vCenter and cross-vCenter migrations, this list can be empty, in which case, the user should set either RelocateSpec.datastore or PlacementSpec.datastores as the target datastore or the list of compatible datastores.  ***Since:*** vSphere API 6.0  Refers instances of *StoragePod*. ", alias="storagePods")
    disallow_prerequisite_moves: Optional[StrictBool] = Field(default=None, description="Specification for whether to disable pre-requisite vmotions or storage vmotions for virtual machine placement.  The default value is true, that is, to disallow such prerequisite moves.  ***Since:*** vSphere API 6.0 ", alias="disallowPrerequisiteMoves")
    rules: Optional[List[ClusterRuleInfo]] = Field(default=None, description="A list of rules to respect while placing the virtual machine on target cluster.  If the list is empty, rules will not be considered during placement, in case of cross-cluster placement within a VC and cross VC placement across VCs.  ***Since:*** vSphere API 6.0 ")
    key: Optional[StrictStr] = Field(default=None, description="Client generated identifier as a reference to the placement request  ***Since:*** vSphere API 6.0 ")
    placement_type: Optional[StrictStr] = Field(default=None, description="Type of the placement.  The set of possible values are described in *PlacementSpecPlacementType_enum*  ***Since:*** vSphere API 6.0 ", alias="placementType")
    clone_spec: Optional[VirtualMachineCloneSpec] = Field(default=None, alias="cloneSpec")
    clone_name: Optional[StrictStr] = Field(default=None, description="Name for the cloned virtual machine, if the operation type is a clone  ***Since:*** vSphere API 6.0 ", alias="cloneName")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of PlacementSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of PlacementSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


