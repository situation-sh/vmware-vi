# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictStr
from pydantic import Field
from vmware_vi.models.key_value import KeyValue
from vmware_vi.models.managed_object_reference import ManagedObjectReference
from vmware_vi.models.ovf_consumer_ost_node import OvfConsumerOstNode
from vmware_vi.models.ovf_manager_common_params import OvfManagerCommonParams
from vmware_vi.models.ovf_network_mapping import OvfNetworkMapping
from vmware_vi.models.ovf_resource_map import OvfResourceMap
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OvfCreateImportSpecParams(OvfManagerCommonParams):
    """
    Parameters for deploying an OVF.  ***Since:*** vSphere API 4.0 
    """ # noqa: E501
    entity_name: StrictStr = Field(description="The name to set on the entity (more precisely, on the top-level vApp or VM of the entity) as it appears in VI.  If empty, the product name is obtained from the ProductSection of the descriptor. If that name is not specified, the ovf:id of the top-level entity is used.  ***Since:*** vSphere API 4.0 ", alias="entityName")
    host_system: Optional[ManagedObjectReference] = Field(default=None, alias="hostSystem")
    network_mapping: Optional[List[OvfNetworkMapping]] = Field(default=None, description="The mapping of network identifiers from the descriptor to networks in the VI infrastructure.  The privilege Network.Assign is required on all networks in the list.  ***Since:*** vSphere API 4.0 ", alias="networkMapping")
    ip_allocation_policy: Optional[StrictStr] = Field(default=None, description="The IP allocation policy chosen by the caller.  See *VAppIPAssignmentInfo*.  ***Since:*** vSphere API 4.0 ", alias="ipAllocationPolicy")
    ip_protocol: Optional[StrictStr] = Field(default=None, description="The IP protocol chosen by the caller.  See *VAppIPAssignmentInfo*.  ***Since:*** vSphere API 4.0 ", alias="ipProtocol")
    property_mapping: Optional[List[KeyValue]] = Field(default=None, description="The assignment of values to the properties found in the descriptor.  If no value is specified for an option, the default value from the descriptor is used.  ***Since:*** vSphere API 4.0 ", alias="propertyMapping")
    resource_mapping: Optional[List[OvfResourceMap]] = Field(default=None, description="Deprecated as of vSphere API 5.1.  The resource configuration for the created vApp.  This can be used to distribute a vApp across multiple resource pools (and create linked children).  ***Since:*** vSphere API 4.1 ", alias="resourceMapping")
    disk_provisioning: Optional[StrictStr] = Field(default=None, description="An optional disk provisioning.  If set, all the disks in the deployed OVF will have get the same specified disk type (e.g., thin provisioned). The valide values for disk provisioning are: - *monolithicSparse* - *monolithicFlat* - *twoGbMaxExtentSparse* - *twoGbMaxExtentFlat* - *thin* - *thick* - *sparse* - *flat* - *seSparse*    See also *VirtualDiskMode_enum*.  ***Since:*** vSphere API 4.1 ", alias="diskProvisioning")
    instantiation_ost: Optional[OvfConsumerOstNode] = Field(default=None, alias="instantiationOst")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OvfCreateImportSpecParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OvfCreateImportSpecParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


