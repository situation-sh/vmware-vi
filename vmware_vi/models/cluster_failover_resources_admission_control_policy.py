# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictInt
from pydantic import Field
from vmware_vi.models.cluster_das_admission_control_policy import ClusterDasAdmissionControlPolicy
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ClusterFailoverResourcesAdmissionControlPolicy(ClusterDasAdmissionControlPolicy):
    """
    The *ClusterFailoverResourcesAdmissionControlPolicy* reserves a specified percentage of aggregate cluster resources for failover.  With the resources failover policy in place, vSphere HA uses the following calculations to control virtual machine migration in the cluster. 1. Calculate the total resource requirements for all powered-on    virtual machines in the cluster. 2. Calculate the total host resources available for virtual machines. 3. Calculate the Current CPU failover capacity, memory failover    capacity and optionally, persistent memory failover capacity    for the cluster. 4. Compare the current CPU failover capacity and current memory failover    capacity with the configured resource percentages    (*ClusterFailoverResourcesAdmissionControlPolicy.cpuFailoverResourcesPercent*    and    *ClusterFailoverResourcesAdmissionControlPolicy.memoryFailoverResourcesPercent*).    If either current capacity is less than the corresponding configured    capacity, HA does not allow the operation.     HA uses the actual reservations of the virtual machines. If a virtual machine does not have reservations, meaning that the reservation is 0, a default of 0MB memory and 256MHz CPU is applied. This is controlled by the same HA advanced options used for the failover level policy (*ClusterFailoverLevelAdmissionControlPolicy*).  ***Since:*** vSphere API 4.0 
    """ # noqa: E501
    cpu_failover_resources_percent: StrictInt = Field(description="Percentage of CPU resources in the cluster to reserve for failover.  You can specify up to 100% of CPU resources for failover.  ***Since:*** vSphere API 4.0 ", alias="cpuFailoverResourcesPercent")
    memory_failover_resources_percent: StrictInt = Field(description="Percentage of memory resources in the cluster to reserve for failover.  You can specify up to 100% of memory resources for failover.  ***Since:*** vSphere API 4.0 ", alias="memoryFailoverResourcesPercent")
    failover_level: Optional[StrictInt] = Field(default=None, description="Number of host failures that should be tolerated, still guaranteeing sufficient resources to restart virtual machines on available hosts.  If not set, we assume 1.  ***Since:*** vSphere API 6.5 ", alias="failoverLevel")
    auto_compute_percentages: Optional[StrictBool] = Field(default=None, description="Flag to enable user input values for *ClusterFailoverResourcesAdmissionControlPolicy.cpuFailoverResourcesPercent* and *ClusterFailoverResourcesAdmissionControlPolicy.memoryFailoverResourcesPercent* By default, this is true and the default calculation is using the *ClusterFailoverResourcesAdmissionControlPolicy.failoverLevel* hosts' resources.  If users want to override the percentage values, they must disable the auto-compute by setting this field to false.  ***Since:*** vSphere API 6.5 ", alias="autoComputePercentages")
    p_mem_failover_resources_percent: Optional[StrictInt] = Field(default=None, description="Percentage of persistent memory resources in the cluster to reserve for the failover.  You can specify up to 100% of persistent memory resources for failover.  ***Since:*** vSphere API 7.0.2.0 ", alias="pMemFailoverResourcesPercent")
    auto_compute_p_mem_failover_resources_percent: Optional[StrictBool] = Field(default=None, description="Flag to enable user input values for *ClusterFailoverResourcesAdmissionControlPolicy.pMemFailoverResourcesPercent* By default, this is true and the default calculation is done using the *ClusterFailoverResourcesAdmissionControlPolicy.failoverLevel* hosts' resources.  If a user wants to override the percentage values, they must disable the auto-compute by setting this field to false.  ***Since:*** vSphere API 7.0.2.0 ", alias="autoComputePMemFailoverResourcesPercent")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ClusterFailoverResourcesAdmissionControlPolicy from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ClusterFailoverResourcesAdmissionControlPolicy from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


