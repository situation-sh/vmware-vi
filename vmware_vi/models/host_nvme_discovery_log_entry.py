# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List
from pydantic import StrictBool, StrictInt, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.host_nvme_transport_parameters import HostNvmeTransportParameters
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostNvmeDiscoveryLogEntry(DataObject):
    """
    This data object represents a single entry in the Discovery Log returned by a Discovery controller.  ***Since:*** vSphere API 7.0 
    """ # noqa: E501
    subnqn: StrictStr = Field(description="NVME Qualified name of the discovered subsystem.  Corresponds to the SUBNQN field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec.  ***Since:*** vSphere API 7.0 ")
    subsystem_type: StrictStr = Field(description="NVM Subsystem type.  Corresponds to the SUBTYPE field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec. The set of supported values is described in *HostNvmeDiscoveryLogSubsystemType_enum*.  ***Since:*** vSphere API 7.0 ", alias="subsystemType")
    subsystem_port_id: StrictInt = Field(description="NVM subsystem port ID.  Corresponds to the PORTID field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec. For an overview, see: - \"NVM Express over Fabrics 1.0\", Section 1.5.2,   NVM Subsystem    ***Since:*** vSphere API 7.0 ", alias="subsystemPortId")
    controller_id: StrictInt = Field(description="NVME Controller ID within the NVM subsystem.  Corresponds to the CNTLID field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec. In the static controller model, this field may be set to a specific controller ID which can be used to connect to that particular controller. It could also be set to 0xFFFE (65534 in decimal), in which case the controller ID will be allocated when a connection is established. In the dynamic controller model, this field shall be set to 0xFFFF (65535 in decimal). Note that this is different from the controllerNumber *HostNvmeController.controllerNumber*, which is the unique identifier of the NVMe controller within the entire host and is allocated only after a connection is established.  ***Since:*** vSphere API 7.0 ", alias="controllerId")
    admin_queue_max_size: StrictInt = Field(description="The maximum size of the Admin Submission Queue.  Corresponds to the ASQSZ field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec. This applies to all controllers within the NVM Subsystem. When establishing a connection, the value of *HostNvmeConnectSpec.adminQueueSize* may not exceed this value.  ***Since:*** vSphere API 7.0 ", alias="adminQueueMaxSize")
    transport_parameters: HostNvmeTransportParameters = Field(alias="transportParameters")
    transport_requirements: StrictStr = Field(description="The requirements for NVME Transport.  Corresponds to the TREQ field in the Discovery Log Page Entry as specified by the NVME over Fabrics spec The set of possible values is described in *HostNvmeDiscoveryLogTransportRequirements_enum*  ***Since:*** vSphere API 7.0 ", alias="transportRequirements")
    connected: StrictBool = Field(description="Indicates whether the controller represented by this Discovery Log Page Entry is already connected to the adapter through which the discovery is initiated.  ***Since:*** vSphere API 7.0 ")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostNvmeDiscoveryLogEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostNvmeDiscoveryLogEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


