# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictStr
from pydantic import Field
from vmware_vi.models.managed_object_reference import ManagedObjectReference
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class CreateContainerViewRequestType(BaseModel):
    """
    The parameters of *ViewManager.CreateContainerView*. 
    """ # noqa: E501
    container: ManagedObjectReference
    type: Optional[List[StrictStr]] = Field(default=None, description="An optional list of managed entity types. The server associates only objects of the specified type(s) with the view. If you specify an empty array, the server uses all types. ")
    recursive: StrictBool = Field(description="Whether to include only the immediate children of the container instance, or to include additional objects by following paths beyond the immediate children.  When recursive is false, the list of objects contains only immediate children. When recursive is true, the server populates the list by following references beyond the immediate children (using a child's references, and then references in the resulting objects, and so on).  Depending on the container type, the server will use the following properties of the container instance to obtain objects for the view's object list: - *Folder* object - *Folder.childEntity*   property.   If recursive is false, the container list includes the reference   to the child entity in the folder instance.   If recursive is true, the server will follow the child   folder path(s) to collect additional childEntity references. - *ResourcePool* object - *ResourcePool.vm*   and *ResourcePool.resourcePool* properties.   If recursive is false, the object list will contain references   to the virtual machines associated with this resource pool,   and references to virtual machines associated with the   immediate child resource pools. If recursive is true,   the server will follow all child resource pool paths   extending from the immediate children (and their children,   and so on) to collect additional references to virtual machines. - *ComputeResource* object - *ComputeResource.host*   and *ComputeResource.resourcePool* properties.   If recursive is false, the object list will contain references   to the host systems associated with this compute resource,   references to virtual machines associated with the   host systems, and references to virtual machines associated   with the immediate child resource pools.   If recursive is true, the server will follow the child   resource pool paths (and their child resource pool paths,   and so on) to collect additional references to virtual machines. - *Datacenter* object - *Datacenter.vmFolder*,   *Datacenter.hostFolder*,   *Datacenter.datastoreFolder*, and   *Datacenter.networkFolder* properties.   If recursive is set to false, the server uses the   immediate child folders for the virtual machines,   hosts, datastores, and networks associated with this   datacenter. If recursive is set to true, the server   will follow the folder paths to collect references   to additional objects. - *HostSystem* object - *HostSystem.vm*   property.   The view object list contains references to the virtual machines   associated with this host system. The value of recursive does not   affect this behavior. ")
    __properties: ClassVar[List[str]] = ["container", "type", "recursive"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of CreateContainerViewRequestType from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of container
        if self.container:
            _dict['container'] = self.container.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of CreateContainerViewRequestType from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "container": ManagedObjectReference.from_dict(obj.get("container")) if obj.get("container") is not None else None,
            "type": obj.get("type"),
            "recursive": obj.get("recursive")
        })
        return _obj


