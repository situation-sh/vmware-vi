# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List

from vmware_vi.models.virtual_device_uri_backing_info import VirtualDeviceURIBackingInfo
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class VirtualSerialPortURIBackingInfo(VirtualDeviceURIBackingInfo):
    """
    The <code>*VirtualSerialPortURIBackingInfo*</code> data object specifies network backing for a <code>*VirtualSerialPort*</code>.  You can use URI backing to create a network serial port on the virtual machine, supporting connections between the virtual machine and remote systems.  When a virtual machine establishes a connection with a remote system on the network, the virtual machine can act as a server or a client. When the virtual machine acts as a server, it accepts a connection. When the virtual machine acts as a client, it initiates the connection.  You can configure the virtual serial port for communication through a virtual serial port concentrator that acts as a proxy between the virtual machine and the network. When you specify a <code>*VirtualDeviceURIBackingInfo.proxyURI*</code>, the virtual machine initiates the connection with the concentrator and forwards the <code>*VirtualDeviceURIBackingInfo.direction*</code> and <code>*VirtualDeviceURIBackingInfo.serviceURI*</code> to the concentrator. For information about using a virtual serial port concentrator, see _Using a Proxy with vSphere Virtual Serial Ports_.  ESX hosts support different protocols depending on your virtual serial port configuration. - If the virtual machine is handling the network connection   directly (no <code>*VirtualDeviceURIBackingInfo.proxyURI*</code> specified),   you can use telnet, TCP, and SSL protocols.   The <code>*VirtualDeviceURIBackingInfo.serviceURI*</code>   must use one of the following URI schemes:   - <code>&lt;host&gt;:&lt;port&gt;</code> - this is the equivalent of     <code>tcp://&lt;host&gt;:&lt;port&gt;</code>.   - <code>tcp://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection     (IPv4 or IPv6).   - <code>tcp4://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection     (IPv4 only).   - <code>tcp6://&lt;host&gt;:&lt;port&gt;</code> - unencrypted TCP connection     (IPv6 only).   - <code>ssl://&lt;host&gt;:&lt;port&gt;</code> - this is the equivalent of     <code>tcp+ssl://&lt;host&gt;:&lt;port&gt;</code>.   - <code>tcp+ssl://&lt;host&gt;:&lt;port&gt;</code> - encrypted SSL over TCP.   - <code>tcp4+ssl://&lt;host&gt;:&lt;port&gt;</code> - SSL over TCP over IPv4.   - <code>tcp6+ssl://&lt;host&gt;:&lt;port&gt;</code> - SSL over TCP over IPv6.   - <code>telnet://&lt;host&gt;:&lt;port&gt;</code> - telnet over TCP.     The virtual machine and remote system can negotiate and use SSL if the remote     system supports the telnet authentication option; if not, the connection     uses unencrypted text (plaintext).   - <code>telnets://&lt;host&gt;:&lt;port&gt;</code> - telnet over SSL over TCP.     In this case, SSL negotiation begins immediately and you cannot use     the telnet authentication option.        As of vSphere 5.1 you can specify authentication parameters to support an encrypted   connection with a remote system using SSL over telnet or telnets.   The connection will fail if the peer does not support the protocols.   You cannot use certificate verification when you specify   <code>tcp</code>, <code>tcp4</code>, or <code>tcp6</code> schemas. For information   about parameter specification, see <a href=\"#authparam\">Authentication Parameters</a>   below. - If you are using a <code>*VirtualDeviceURIBackingInfo.proxyURI*</code>   to connect to a virtual serial port concentrator, the URI scheme for   the communication between the remote system on the network and the concentrator   depends on the concentrator implementation. The connection between   the concentrator and the virtual serial port must use telnet or secure telnet   (telnets). The proxy URI must use one of the following URI schemes. You cannot   specify a username and password in the proxy URI.   - <code>telnet://&lt;host&gt;:&lt;port&gt;</code>- telnet over TCP.     The virtual machine and remote system can negotiate and use SSL if the remote     system supports the telnet authentication option; if not, the connection     uses unencrypted text (plaintext).   - <code>telnets://&lt;host&gt;:&lt;port&gt;</code> - telnet over SSL over TCP.     In this case, SSL negotiation starts immediately and you cannot use     the telnet authentication option.        As of vSphere 5.1 you can specify authentication parameters to support an encrypted   connection with a concentrator using SSL over telnet or telnets.   The connection will fail if the concentrator does not support the protocols.   For information about parameter specification,   see <a href=\"#authparam\">Authentication Parameters</a> below.    <a name=\"authparam\"></a> **Authentication Parameters**      For an encrypted connection, the URI includes a set of authentication parameters. The parameters are specified as key words or key/value pairs. The following syntax description uses <code>telnet</code>; you can also specify authentication parameters for secure telnet (<code>telnets</code>).  <code>telnet://&lt;host&gt;:&lt;port&gt;&num;key\\[=value\\]\\[&amp;key\\[=value\\] ...\\]</code>  The first parameter must have a number sign (&num;) prefix. Additional parameters must have an ampersand (&amp;) prefix. The following list shows the valid parameters. - <code>thumbprint=value</code> - Specifies a certificate thumbprint against   which the peer certificate thumbprint is compared. When you specify a thumbprint,   certificate verification is automatically enabled. See the description of the   <code>verify</code> parameter below. - <code>peerName=value</code> - Specifies the peer name that will be used   to validate the peer certificate. When you specify a peer name,   certificate verification is automatically enabled. See the description of the   <code>verify</code> parameter below. - <code>verify</code> - Forces certificate verification. The virtual machine   will verify that the peer certificate subject matches the specified   <code>peerName</code> and that it was signed by a certificate authority   known to the ESXi host. Verification is automatically enabled if you specify a   <code>thumbprint</code> or <code>peerName</code>. - <code>cipherList=value</code> - Specifies a list of SSL ciphers.   See <a href=\"http://www.openssl.org/docs/apps/ciphers.html\">OpenSSL ciphers</a>.   The ciphers are specified as a list separated by colons, spaces, or commas.    For information about URI format, see <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>.  ***Since:*** vSphere API 4.1 
    """ # noqa: E501
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of VirtualSerialPortURIBackingInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of VirtualSerialPortURIBackingInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


