# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List
from pydantic import StrictBool
from pydantic import Field
from vmware_vi.models.virtual_device import VirtualDevice
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class VirtualSerialPort(VirtualDevice):
    """
    The <code>*VirtualSerialPort*</code> data object represents a serial port on a virtual machine.  A virtual serial port uses one of the following backing types to specify how the virtual machine performs serial port operations. - Network backing (<code>*VirtualSerialPortURIBackingInfo*</code>)   supports a connection between the virtual machine and a resource   on the network. The virtual machine can initiate a connection with   the network resource, or it can listen for connections originating   from the network. - Pipe backing (<code>*VirtualSerialPortPipeBackingInfo*</code>)   supports I/O through a named pipe. The pipe connects the virtual machine   to a host application or a virtual machine on the same host. - File backing (<code>*VirtualSerialPortFileBackingInfo*</code>)   supports output through the virtual serial port to a file on the same host. - Physical serial port backing   (<code>*VirtualSerialPortDeviceBackingInfo*</code>)   supports a connection between the virtual machine and a   device that is connected to a physical serial port on the host. - ThinPrint backing (<code>*VirtualSerialPortThinPrintBackingInfo*</code>)   provides driver-free printing.    When you use network backing, you can also configure a virtual serial port to use a virtual serial port concentrator. The virtual machine initiates a telnet connection with the concentrator, and the concentrator acts as a proxy between the virtual machine and a system on the network. By using a virtual serial port concentrator, you can maintain the connection between the virtual machine and the network resource when a vMotion event moves the virtual machine from one host to another. Without a virtual serial port concentrator, the connection would be lost. For information about using a serial port concentrator, see _Using a Proxy with vSphere Virtual Serial Ports_.  You can configure a virtual serial port when you create or reconfigure a virtual machine. For example, to create a virtual serial port with network backing, use the following sequence of operations. In this procedure, the virtual serial port uses a proxy and will accept a network connection. 1. Use the <code>*EnvironmentBrowser.QueryConfigOption*</code> method    to determine the backing options that are available on a host.    The method returns a <code>*VirtualMachineConfigOption*</code> data object.    The virtual machine configuration data includes a list of backing options    (<code>*VirtualDeviceOption.backingOption*</code>).    The following pseudocode shows the path to the backing options.            &nbsp;&nbsp;&nbsp;&nbsp;<code>*VirtualMachineConfigOption*.hardwareOptions.VirtualDeviceOption\\[\\].backingOption\\[\\]</code>            The array of virtual device options can include a virtual serial port    (<code>*VirtualSerialPortOption*</code>). The array of serial port    backing options can include URI, file, pipe, or device backing options. 2. Use the <code>*Folder.CreateVM_Task*</code> method    (or the <code>*ResourcePool.CreateChildVM_Task*</code> method)    to create the virtual machine and configure the virtual serial port backing.    Create a <code>*VirtualMachineConfigSpec*</code> data object and nested    data objects for the method's <code>config</code> parameter.    The following pseudocode shows the resulting path to the backing    information.            &nbsp;&nbsp;&nbsp;&nbsp;<code>*VirtualMachineConfigSpec*.deviceChange\\[\\].device.backing</code>            Set the direction property to \"server\" to direct the virtual machine to accept    a connection. Set the serviceURI property to the URI for the host on which    the virtual machine runs.     If you use physical device backing (<code>*VirtualSerialPortDeviceBackingOption*</code>), you should also use the <code>*EnvironmentBrowser.QueryConfigTarget*</code> method to determine if a serial device is available before configuring device backing. 
    """ # noqa: E501
    yield_on_poll: StrictBool = Field(description="Enables CPU yield behavior.  If you set <code>yieldOnPoll</code> to <code>true</code>, the virtual machine will periodically relinquish the processor if its sole task is polling the virtual serial port. The amount of time it takes to regain the processor will depend on the degree of other virtual machine activity on the host.  To use this property, the CPU yield option must be supported. (See the <code>*VirtualSerialPortOption.yieldOnPoll*</code> property for the virtual serial port option object.) ", alias="yieldOnPoll")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of VirtualSerialPort from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of VirtualSerialPort from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


