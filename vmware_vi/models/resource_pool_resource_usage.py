# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List
from pydantic import StrictInt
from pydantic import Field
from vmware_vi.models.data_object import DataObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ResourcePoolResourceUsage(DataObject):
    """
    Specifies the resource usage for either memory or CPU.  For CPU the unit is MHz, for memory the unit is bytes.  In the typical case, where a resourcepool is in a consistent state, unreservedForVm will be equal to unreservedForPool. Hence, we can simply say talk about unreserved resources.  If the reservation on the resource pool is not expandable, then the following is true:                 reservation = reservationUsed + unreserved If the reservation on the resource pool is expandable, then the following is true:            reservation + parent.unreserved = reservationUsed + unreserved 
    """ # noqa: E501
    reservation_used: StrictInt = Field(description="Total amount of resources that have been used to satisfy the reservation requirements of all descendants of this resource pool (includes both resource pools and virtual machines). ", alias="reservationUsed")
    reservation_used_for_vm: StrictInt = Field(description="Total amount of resources that have been used to satisfy the reservation requirements of running virtual machines in this resource pool or any of its child resource pools. ", alias="reservationUsedForVm")
    unreserved_for_pool: StrictInt = Field(description="Total amount of resources available to satisfy a reservation for a child resource pool.  In the undercommitted state, this is limited by the capacity at the root node. In the overcommitted case, this could be higher since we do not perform the dynamic capacity checks. ", alias="unreservedForPool")
    unreserved_for_vm: StrictInt = Field(description="Total amount of resources available to satisfy a reservation for a child virtual machine.  In general, this should be the same as *ResourcePoolResourceUsage.unreservedForPool*. However, in the overcommitted case, this is limited by the remaining available resources at the root node. ", alias="unreservedForVm")
    overall_usage: StrictInt = Field(description="Deprecated as of vSphere API 6.5. Use *ResourcePoolQuickStats.overallCpuUsage* and *ResourcePoolQuickStats.hostMemoryUsage*.  Close to real-time resource usage of all running child virtual machines, including virtual machines in child resource pools. ", alias="overallUsage")
    max_usage: StrictInt = Field(description="Current upper-bound on usage.  The upper-bound is based on the limit configured on this resource pool, as well as limits configured on any parent resource pool. ", alias="maxUsage")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ResourcePoolResourceUsage from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ResourcePoolResourceUsage from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


