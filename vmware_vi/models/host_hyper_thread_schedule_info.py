# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List
from pydantic import StrictBool
from pydantic import Field
from vmware_vi.models.data_object import DataObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostHyperThreadScheduleInfo(DataObject):
    """
    This data object type describes the CpuSchedulerSystem configuration for optimizing hyperthreading.  The primary hyperthreading optimization employed by the CpuSchedulerSystem is to utilize hyperthreads as additional schedulable resources. Although hyperthreads provide limited additional concurrency, certain workloads (such as idling) can take advantage of these hyperthreads. This is particularly useful for SMP virtual machines that use gang scheduling. (Gang scheduling refers to a situation in which all of a parallel program's tasks are grouped into a \"gang\" and concurrently scheduled on distinct processors of a parallel computer system.)  Changes to the hyperthreading optimization can take effect only after a system restart. Therefore, while it is possible to change the configuration at any time, the change will take effect only on the next boot. 
    """ # noqa: E501
    available: StrictBool = Field(description="The flag to indicate whether or not hyperthreading optimization is available on the system.  This property is set by VMware prior to installation. ")
    active: StrictBool = Field(description="The flag to indicate whether or not the CPU scheduler is currently treating hyperthreads as schedulable resources.  Setting this property involves a successful invocation of either the *enableHyperThreading()* method (\"true\") or the *disableHyperthreading()* method (\"false\"). The property is set once the system is rebooted. ")
    config: StrictBool = Field(description="The flag to indicate whether or not the CPU scheduler should treat hyperthreads as schedulable resources the next time the CPU scheduler starts. - This property is set to \"true\" by successfully invoking the   *enableHyperThreading()* method. - This property is set to \"false\" by successfully invoking the   *disableHyperthreading()* method. ")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostHyperThreadScheduleInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostHyperThreadScheduleInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


