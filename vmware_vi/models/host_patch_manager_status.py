# coding: utf-8

"""
    Virtual Infrastructure JSON API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 8.0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import StrictBool, StrictStr
from pydantic import Field
from vmware_vi.models.data_object import DataObject
from vmware_vi.models.host_patch_manager_status_prerequisite_patch import HostPatchManagerStatusPrerequisitePatch
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HostPatchManagerStatus(DataObject):
    """
    HostPatchManagerStatus
    """ # noqa: E501
    id: StrictStr = Field(description="Unique identifier for this update. ")
    applicable: StrictBool = Field(description="Whether or not this update is applicable to this host.  An update may not be applicable to the ESX host for many reasons - for example, it is obsolete, it conflicts with other installed patches or libraries, and so on. The *HostPatchManagerStatus.reason* shows some of the reasons why the update is not applicable. An update could be inapplicable with no reason listed. This is because the prerequisite install state is not correct. For example, update A is one of the prerequisites of update B. B not only requires A to be installed, but also requires the host is rebooted after A is installed. When A is installed and the host has not been restarted after the installation, B will not be applicable. In such a case, the scan on both updates A and B would yield a whole picture of the update applicable status. ")
    reason: Optional[List[StrictStr]] = Field(default=None, description="Possible reasons why an update is not applicable to the ESX host.  See also *HostPatchManagerReason_enum*. ")
    integrity: Optional[StrictStr] = Field(default=None, description="The integrity status of the update's metadata.  The value would be unset if the integrity status is unknown to the server.  See also *HostPatchManagerIntegrityStatus_enum*. ")
    installed: StrictBool = Field(description="Whether the update is installed on the server. ")
    install_state: Optional[List[StrictStr]] = Field(default=None, description="The installation state of the update.  Unset if the update is not installed on the server.  See also *HostPatchManagerInstallState_enum*. ", alias="installState")
    prerequisite_patch: Optional[List[HostPatchManagerStatusPrerequisitePatch]] = Field(default=None, description="Prerequisite update. ", alias="prerequisitePatch")
    restart_required: StrictBool = Field(description="Whether or not this update requires a host restart to take effect. ", alias="restartRequired")
    reconnect_required: StrictBool = Field(description="Whether or not this update requires caller to reconnect to the host.  This is usually because the update is on the agent that running on the host, the agent would thus be restarted when the update is applied. Caller can reconnect (and possibly relogin) to the host after the agent has been restarted. ", alias="reconnectRequired")
    vm_off_required: StrictBool = Field(description="Whether or not this update requires the host in maintenance mode. ", alias="vmOffRequired")
    superseded_patch_ids: Optional[List[StrictStr]] = Field(default=None, description="Patches that are superseded by this update. ", alias="supersededPatchIds")
    __properties: ClassVar[List[str]] = ["_typeName"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HostPatchManagerStatus from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HostPatchManagerStatus from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_typeName": obj.get("_typeName")
        })
        return _obj


